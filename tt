#!/usr/bin/env python3
import sys
import re
import os

################################################################################
# MAIN SECTION

DEFAULT_TODO_FILE = os.path.join(os.path.expanduser("~"), "todo.txt")

#   understand/
# main entry point into our program
def main():
    try:
        c, ar = processCmdLineArgs()
        if ar or ar == "":
            c(ar)
        else:
            c()
    except Exception as e:
        print(str(e))
        raise


################################################################################
# ARGV SECTION

#   understand/
# handle the command-line arguments and return
# a tuple of (command, argument, error)
def processCmdLineArgs():
    if len(sys.argv) == 1:
        return (showBriefHelp, None)

    cmd = sys.argv[1]
    args = ' '.join(sys.argv[2:])

    if cmd == "+":
        return (add_todo, args)

    if cmd == "x":
        return ("mark_done", args)

    if not cmd.startswith("-"):
        return (search, ' '.join(sys.argv[1:]))

    cmd = re.sub("^-+", "", cmd)

    if cmd == "v":
        return (search_verbose, args)

    if cmd == "c" or cmd == "copy":
        return (search_copy, args)

    if cmd == "t":
        if len(sys.argv) > 2:
            raise Exception('"-t" cannot have any arguments')
        return ("tag_list", None)

    if cmd == "hh" or cmd == "man":
        return (showDetailedHelp, None)

    return (showBriefHelp, None)

################################################################################
# ADD SECTION

#       way/
# extract tags and write the line to
# the appropriate file at the end of the
# tag heading block or default to writing
# to the HOME/todo.txt as a single line
def add_todo(line):
    location = None
    (tags, txt) = tagify(line)
    if tags:
        location = find_location(load(), tags)
    append_to_file(txt, tags, location)

#       way/
# if we are not given a location, then we do a default
# append, otherwise we append to the given location
def append_to_file(txt, tags, location):
    if location:
        append_at_location(txt, tags, location)
    else:
        append_default(txt, tags)


#       way/
# go to the end of the heading section and append
# the text there
def append_at_location(txt, tags, location):
    file, lnum = location
    txt = "+ " + txt
    print("{0}:{1}: {2}".format(file, lnum+1, txt))
    with open(file, "r+") as f:
        contents = f.readlines()
        contents.insert(lnum, txt + "\n")
        f.seek(0)
        f.writelines(contents)


#       way/
# open the default file and append a new line with the
# text and tags
def append_default(txt, tags):
    if tags:
        txt += " " + " ".join([":"+tag for tag in tags])
    txt = "+ " + txt
    print("{0}: {1}".format(DEFAULT_TODO_FILE, txt))
    with open(DEFAULT_TODO_FILE, "a") as f:
        f.write(txt + "\n")


#       way/
# walk the entries and find any headings where
# the tags match the given tags, then walk down
# to the end of the block and return that location
def find_location(entries, tags):
    tags = set(tags)
    ndx = 0
    lnum = None
    for entry in entries:
        ndx += 1
        if entry.type == "heading" and tags == set(entry.tags):
            lnum = entry.endnum()
            for entry in entries[ndx:]:
                if entry.type == "heading" and tags != set(entry.tags):
                    return entry.fname, lnum
                else:
                    lnum = entry.endnum()


################################################################################
# SEARCH SECTION

def filter(todos, s):
    return todos

#       way/
# filter all the todo's then show them
# in a clean, minimal output
def search(s):
    todos = filter(load(), s)
    for entry in todos:
        if entry.tags and "later" in entry.tags:
            continue
        if entry.done:
            continue
        if entry.type == "note":
            print(entry.note)
        elif entry.type == "todo":
            if entry.item:
                indent = "\t" * entry.ndnt()
                print(indent + entry.item)
        elif entry.type == "heading":
            pass
        else:
            print(vars(entry))
            raise Exception('Did not understand type: ' + entry.type)

#       way/
# filter all the todo's then show them
# in a valid todo format to copy into
# another file
def search_copy(s):
    todos = filter(load(), s)
    seen = []
    for entry in todos:
        seen.append(entry)
        if entry.type == "note":
            print(entry.note)
        elif entry.type == "heading":
            hdr = "#" * (entry.ndnt()+1)
            tags = remove_tags_1(seen, entry)
            tags = [t.title() for t in tags]
            tags.sort()
            tags = " ".join(tags)
            print("{0} {1}".format(hdr, tags))
        elif entry.type == "todo":
            indent = "  " * entry.ndnt()
            done = ""
            if entry.done:
                done = "x"
            tags = remove_tags_1(seen, entry)
            tags = [":"+t for t in tags]
            tags.sort()
            tags = " ".join(tags)
            if tags and entry.item:
                print("{0}{1}* {2} {3}".format(done, indent, entry.item, tags))
            elif entry.item:
                print("{0}{1}* {2}".format(done, indent, entry.item))
            elif tags:
                print("{0}{1}* {2}".format(done, indent, tags))
        else:
            print(vars(entry))
            raise Exception('Did not understand type: ' + entry.type)


def remove_tags_1(seen, entry):
    tags = set()

    if not entry.tags:
        return tags

    tags.update(entry.tags)

    for todo in reversed(seen):
        if todo.type == "heading":
            if entry.type == "heading":
                if todo.ndnt() < entry.ndnt():
                    return tags.difference(todo.tags)
            else:
                return tags.difference(todo.tags)

        if todo.type == "todo":
            if entry.type != "heading":
                if todo.ndnt() < entry.ndnt():
                    return tags.difference(todo.tags)

    return tags


#       way/
# filter all the todo's then show them
# in a nice output along with all
# the filenames
def search_verbose(s):
    todos = filter(load(), s)
    files = set()
    for entry in todos:
        files.add(entry.fname)
        status = "TODO"
        if entry.tags and "later" in entry.tags:
            status = "LATR"
        if entry.done:
            status = "DONE"
        if entry.type == "note":
            tags = ""
            if entry.tags:
                tags = "({0})".format(",".join(entry.tags))
            for line in entry.note.split("\n"):
                print("NOTE\t" + tags + "\t" + line)
        elif entry.type == "todo":
            if entry.item:
                indent = "\t" * entry.ndnt()
                tags = "(:)"
                if entry.tags:
                    tags = "({0})".format(",".join(entry.tags))
                print("{0}\t{3}\t{1}{2}".format(status,indent, entry.item, tags))
        elif entry.type == "heading":
            pass
        else:
            print(vars(entry))
            raise Exception('Did not understand type: ' + entry.type)
    print("\n")
    files = list(files)
    files.sort()
    for fname in files:
        print(fname)

################################################################################
# ENGINE SECTION

class Entry:
    def __init__(self, lnum, fname):
        self.fname = fname
        self.lnum = lnum
        self.type = None
        self.note = None
        self.item = None
        self.tags = None
        self.indent = None
        self.done = False

    def addTags(self, tags):
        if not tags:
            return
        if not self.tags:
            self.tags = set()
        self.tags.update([tag.lower() for tag in tags])

    def ndnt(self):
        if self.indent:
            return self.indent
        return 0

    def endnum(self):
        return getattr(self, "enum", self.lnum)

#       understand/
# add the "todo.txt" in the current directory (if it exists),
# and the "todo.txt" in the user's HOME directory
# and add the files specified in the "toodle-o.list"
def get_todo_files():
    files = [ "todo.txt", DEFAULT_TODO_FILE ]
    files = [ f for f in files if os.path.exists(f) ]

    conf = os.path.join(os.path.dirname(__file__), "toodle-o.list")
    if os.path.exists(conf):
        with open(conf) as f:
            files.extend([line.strip() for line in f.readlines()])

    return files


#       understand/
# extract :tags from the :line
def tagify(l):
    tags = []
    rx = "(^| ):([-_.+0-9A-Za-z]+)"
    m = re.search(rx, l)
    while m:
        tags.append(m.group(2))
        l = l.replace(m.group(0), '')
        m = re.search(rx, l)
    txt = l.strip()
    return (tags, txt)


#       way/
# read file and parse each line
def parse(f, todos):

    #       problem/
    # parse line by it's type
    #
    #   todos:
    #       *
    #       -
    #       +
    #       #
    #       - [ ]
    #       = Tag =
    #       1.
    #       2.
    #   otherwise notes
    #
    # and recognize it's indent
    #   * ...
    #     * ...
    #   # ...
    #   ## ...
    #   == Tag ==
    #
    # and recognize the "done"
    #   x+ ...
    #   x3. ...
    #   - [X]
    #
    # and the tags
    #   + ... :tag :tag
    #
    #
    #       way/
    # if line matches
    #       == tag name ==
    #       ## tag name ##
    # use that as a `:tag-name` and with a "heading" type
    # otherwise
    # if line starts with `x` mark as "done" and
    # discard.
    # mark the number of leading spaces as "indent" and
    # discard.
    # if the line starts with =,#,*,+,- or
    # [number]. followed by a space it's a todo - clear
    # additional []/[ ]/[x]. Mark [x] and ~~todo~~ as "done"
    # otherwise
    # it is a note
    def parse_(lnum, l, fname):
        done = False
        note = l
        indent = 0

        entry = type_1("^\s*(=+)\s+(.*?)(=+)\s*$", l, fname, lnum)
        if entry:
            return entry
        entry = type_1("^\s*(#+)\s+(.*?)(#*)\s*$", l, fname, lnum)
        if entry:
            return entry

        entry = Entry(lnum, fname)

        if len(l) > 0 and (l[0] == 'x' or l[0] == 'X'):
            l = l[1:]
            done = True

        m = re.match("^\s+", l)
        if m:
            indent = len(m.group(0))

        l = l.lstrip()
        if len(l) > 0:
            m = re.match("^[=#*+-]", l)
            if not m:
                m = re.match("^[0-9]+[.]", l)
            if m:
                l = l[len(m.group(0)):]
                if not l:
                    entry.type = "del"
                    return entry
                if l[0] == ' ':
                    m = re.match("\s*\[([-.x ])?\]", l, re.I)
                    if m:
                        if m.group(1).lower() == "x":
                            done = True
                        l = l.replace(m.group(0), '')
                    m = re.match("^\s*~~.*~~\s*", l)
                    if m:
                        done = True
                        l = l.split("~~")
                        l = l[1:(len(l)-1)]
                        l = "".join(l)
                    (tags, txt) = tagify(l)
                    entry.type = "todo"
                    if tags:
                        entry.addTags(tags)
                    if txt:
                        entry.item = txt
                    if done:
                        entry.done = done
                    if indent > 0:
                        entry.indent = indent
                    return entry


        entry.type = "note"
        entry.note = note
        return entry


    def type_1(rx, l, fname, lnum):
        m = re.match(rx, l)
        if not m:
            return None
        m1 = m.group(1)
        m2 = m.group(3)
        if m2 and m1 != m2:
            return None
        txt = m.group(2).strip()
        if not txt:
            return None
        entry = Entry(lnum, fname)
        entry.type = "heading"
        tag = re.sub("\s+", "-", txt).lower() 
        entry.addTags([tag])
        indent = len(m1) - 1
        if indent > 0:
            entry.indent = indent
        return entry


    #       way/
    # join the notes and add tags of higher indents
    # and headings
    def join_1(entries):
        notes = []
        tags = []
        notenum_s = None
        notenum_e = None

        def add_pending_notes_1():
            nonlocal notes
            nonlocal tags
            nonlocal notenum_s
            nonlocal notenum_e
            n = '\n'.join(notes)
            n = re.sub("^[\n\r]*", "", n)
            n = re.sub("[\n\r]*$", "", n)
            if n:
                entry = Entry(notenum_s, f)
                entry.enum = notenum_e
                entry.type = "note"
                entry.note = n
                if len(tags) > 0:
                    entry.addTags(tags)
                todos.append(entry)
            notes = []
            tags = []
            notenum_s = None
            notenum_e = None

        def update_tags_1(entry):
            for todo in reversed(todos):

                if todo.type == "heading":
                    if entry.type == "heading":
                        if todo.ndnt() < entry.ndnt():
                            entry.addTags(todo.tags)
                            return
                    else:
                        entry.addTags(todo.tags)
                        return

                if todo.type == "todo":
                    if entry.type != "heading":
                        if todo.ndnt() < entry.ndnt():
                            entry.addTags(todo.tags)
                            return

        for entry in entries:
            if entry.type == "del":
                pass
            elif entry.type == "note":
                if len(notes) == 0:
                    notenum_s = entry.lnum
                    if len(todos) > 0:
                        last = todos[len(todos)-1]
                        if last.tags:
                            tags = last.tags
                notes.append(entry.note)
                notenum_e = entry.lnum
            else:
                add_pending_notes_1()
                update_tags_1(entry)
                todos.append(entry)

        add_pending_notes_1()


    #       problem/
    # because the indents are a mix of spaces and
    # tabs and don't really have a "proper" basis
    # they can be somewhat wonky when output
    #
    #       understand/
    # we know the indents are either at top level (0)
    # or bigger than some parent entry before it
    #
    #       way/
    # if the indent = 0, then set "re-ident=0"
    # if the indent > 0, we walk back looking for
    # the parent (indent < this) then set this
    # "re-indent" to the previous "re-indent+1"
    def reindent_1(entries):
        ndx = 0
        for entry in entries:
            if entry.ndnt() == 0:
                entry.reindent = 0
            else:
                entry.reindent = 0
                reindent__1(reversed(entries[:ndx]), entry)
            ndx += 1
        for entry in entries:
            entry.indent = entry.reindent
            del entry.reindent

    def reindent__1(parents, entry):
        for parent in parents:
            if parent.type == "heading":
                if entry.type == "heading":
                    if parent.ndnt() < entry.ndnt():
                        entry.reindent = parent.reindent + 1
                        return
                else:
                    entry.reindent = parent.reindent + 1
                    return

            if parent.type == "todo":
                if entry.type != "heading":
                    if parent.ndnt() < entry.ndnt():
                        entry.reindent = parent.reindent + 1
                        return


    with open(f) as t:
        entries = []
        lnum = 0
        for line in t:
            lnum += 1
            entry = parse_(lnum, line.rstrip(), f)
            entries.append(entry)
        join_1(entries)
        reindent_1(entries)


#       way/
# parse the todo files and return the todos
def load():
    todos = []
    todofiles = get_todo_files()
    for f in todofiles:
        t = []
        parse(f, t)
        todos.extend(t)
    return todos


################################################################################
# HELP SECTION
def showBriefHelp():
    print("""tt: Toodle-O TODO Manager
    $> tt + add todo :tag
    $> tt [:tag] [word]
    $> tt -v :tag
    $> tt -x [:tag] [word]
    $> tt -t

Use -hh (or --man) to see detailed help
    $> tt -hh
""")


def showDetailedHelp():
    print("""tt: Toodle-O TODO Manager

Add a new todo (+)
    $> tt + add a new todo

Add a new todo with tags (:)
    $> tt + buy bread :joes :shopping

Find todo's matching tags or words
    $> tt :shopping bread
    buy bread

Find todo's which don't have tags
    $> tt :
    add a new todo


Use the :later tag to hide items.
These will not be shown by default
unless you use the verbose (-v) flag

Show EVERYTHING:
    $> tt -v [:tag] [word]

Add the -c (copy) to get a list you can copy over
    $> tt -c [:tag] [word]

And -t (tags) to get the list of tags
    $> tt -t

And -x (done) to mark matching items as complete
    $> tt -x :shopping bread
    x buy bread


We will use a "todo.txt" file in the current directory
or, failing to find that, we will create and use a "todo.txt"
file in the HOME directory.
You can also provide a `toodle-o.list` file which contains,
one on each line, a list of `todo` files scattered across various
directories to process.""")

################################################################################

main()

