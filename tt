#!/usr/bin/env python3
import sys
import re
import os

################################################################################
# MAIN SECTION

#   understand/
# main entry point into our program
def main():
    try:
        c, ar = processCmdLineArgs()
        if ar:
            c(ar)
        else:
            c()
    except Exception as e:
        print(str(e))
        raise


################################################################################
# ARGV SECTION

#   understand/
# handle the command-line arguments and return
# a tuple of (command, argument, error)
def processCmdLineArgs():
    if len(sys.argv) == 1:
        return (showBriefHelp, None)

    cmd = sys.argv[1]

    if not cmd.startswith("-"):
        return (search, ' '.join(sys.argv[1:]))
    cmd = re.sub("^-+", "", cmd)

    if cmd == "+":
        return ("add_todo", ' '.join(sys.argv[1:]))

    if cmd == "v":
        return (search_verbose, ' '.join(sys.argv[1:]))

    if cmd == "x":
        return ("mark_done", ' '.join(sys.argv[1:]))

    if cmd == "t":
        if len(sys.argv) > 2:
            raise Exception('"-t" cannot have any arguments')
        return ("tag_list", None)

    if cmd == "hh" or cmd == "man":
        return (showDetailedHelp, None)

    return (showBriefHelp, None)

################################################################################
# SEARCH SECTION
def search_verbose(s):
    # TODO
    pass

def search(s):
    todos = load()
    files = set()
    for entry in todos:
        files.add(entry.fname)
        status = "    "
        if entry.tags and "later" in entry.tags:
            status = "LATER"
        if entry.done:
            status = "DONE"
        if entry.type == "note":
            print(status + "\t" + entry.note)
        elif entry.type == "todo":
            if entry.item:
                indent = "\t" * entry.ndnt()
                tags = ""
                if entry.tags:
                    tags = "\t({0})".format(",".join(entry.tags))
                print("{0}\t{1}{2}{3}".format(status,indent, entry.item, tags))
        elif entry.type == "heading":
            pass
        else:
            print(entry)
            raise Exception('Did not understand type: ' + entry.type)
    print("\n")
    for fname in files:
        print(fname)

################################################################################
# ENGINE SECTION

class Entry:
    def __init__(self, orig, fname):
        self.orig = orig
        self.fname = fname
        self.type = None
        self.note = None
        self.item = None
        self.tags = None
        self.indent = None
        self.done = False

    def ndnt(self):
        if self.indent:
            return self.indent
        return 0

#       way/
# read the files specified in "toodle-o.list" or default to "todo.txt"
def get_todo_files():
    conf = os.path.join(os.path.dirname(__file__), "toodle-o.list")
    if os.path.exists(conf):
        with open(conf) as f:
            return [line.strip() for line in f.readlines()]
    return ["todo.txt"]

#       way/
# read file and parse each line
def parse(f, todos):

    #       problem/
    # parse line by it's type
    #
    #   todos:
    #       *
    #       -
    #       +
    #       #
    #       - [ ]
    #       = Tag =
    #       1.
    #       2.
    #   otherwise notes
    #
    # and recognize it's indent
    #   * ...
    #     * ...
    #   # ...
    #   ## ...
    #   == Tag ==
    #
    # and recognize the "done"
    #   x+ ...
    #   x3. ...
    #   - [X]
    #
    # and the tags
    #   + ... :tag :tag
    #
    #
    #       way/
    # if line matches
    #       == tag name ==
    #       ## tag name ##
    # use that as a `:tag-name` and with a "heading" type
    # otherwise
    # if line starts with `x` mark as "done" and
    # discard.
    # mark the number of leading spaces as "indent" and
    # discard.
    # if the line starts with =,#,*,+,- or
    # [number]. followed by a space it's a todo - clear
    # additional []/[ ]/[x]. Mark [x] and ~~todo~~ as "done"
    # otherwise
    # it is a note
    def parse_(l, fname):
        done = False
        note = l
        indent = 0

        entry = type_1("^\s*(=+)\s+(.*?)(=+)\s*$", l, fname)
        if entry:
            return entry
        entry = type_1("^\s*(#+)\s+(.*?)(#*)\s*$", l, fname)
        if entry:
            return entry

        entry = Entry(l, fname)

        if len(l) > 0 and (l[0] == 'x' or l[0] == 'X'):
            l = l[1:]
            done = True

        m = re.match("^\s+", l)
        if m:
            indent = len(m.group(0))

        l = l.lstrip()
        if len(l) > 0:
            m = re.match("^[=#*+-]", l)
            if not m:
                m = re.match("^[0-9]+[.]", l)
            if m:
                l = l[len(m.group(0)):]
                if not l:
                    entry.type = "del"
                    return entry
                if l[0] == ' ':
                    m = re.match("\s*\[([-.x ])?\]", l, re.I)
                    if m:
                        if m.group(1).lower() == "x":
                            done = True
                        l = l.replace(m.group(0), '')
                    m = re.match("^\s*~~.*~~\s*", l)
                    if m:
                        done = True
                        l = l.split("~~")
                        l = l[1:(len(l)-1)]
                        l = "".join(l)
                    (tags, txt) = tagify_1(l)
                    entry.type = "todo"
                    if tags:
                        entry.tags = tags
                    if txt:
                        entry.item = txt
                    if done:
                        entry.done = done
                    if indent > 0:
                        entry.indent = indent
                    return entry


        entry.type = "note"
        entry.note = note
        return entry


    def tagify_1(l):
        tags = []
        rx = "\b:([^\s]+):?\b"
        m = re.search(rx, l)
        while m:
            tags.append(m.group(1))
            l = l.replace(m.group(0), '')
            m = re.search(rx, l)
        txt = l.strip()
        return (tags, txt)

    def type_1(rx, l, fname):
        m = re.match(rx, l)
        if not m:
            return None
        m1 = m.group(1)
        m2 = m.group(3)
        if m2 and m1 != m2:
            return None
        txt = m.group(2).strip()
        if not txt:
            return None
        entry = Entry(l, fname)
        entry.type = "heading"
        entry.tags = [ re.sub("\s+", "-", txt).lower() ]
        indent = len(m1) - 1
        if indent > 0:
            entry.indent = indent
        return entry


    #       way/
    # join the notes and add tags of higher indents
    # and headings
    def join_1(entries):
        notes = []
        tags = []

        def add_pending_notes_1():
            nonlocal notes
            nonlocal tags
            n = '\n'.join(notes).strip()
            if n:
                entry = Entry(None, f)
                entry.type = "note"
                entry.note = n
                if len(tags) > 0:
                    entry.tags = tags
                todos.append(entry)
            notes = []
            tags = []

        def update_tags_1(entry):
            for todo in reversed(todos):
                if todo.type == "heading":
                    if entry.type == "heading":
                        if todo.ndnt() < entry.ndnt():
                            if entry.tags:
                                entry.tags.extend(todo.tags)
                            else:
                                entry.tags = todo.tags
                    else:
                        if entry.tags:
                            entry.tags.extend(todo.tags)
                        else:
                            entry.tags = todo.tags
                    return
                if todo.type != "todo":
                    continue
                if todo.ndnt() < entry.ndnt():
                    if todo.tags:
                        if entry.tags:
                            entry.tags.extend(todo.tags)
                        else:
                            entry.tags = todo.tags
                    return

        for entry in entries:
            if entry.type == "del":
                pass
            elif entry.type == "note":
                if len(notes) == 0:
                    if len(todos) > 0:
                        last = todos[len(todos)-1]
                        if last.tags:
                            tags = last.tags
                notes.append(entry.note)
            else:
                add_pending_notes_1()
                update_tags_1(entry)
                todos.append(entry)

        add_pending_notes_1()




    with open(f) as t:
        lines = []
        for line in t:
            l = parse_(line.rstrip(), f)
            lines.append(l)
        join_1(lines)


#       way/
# parse the todo files and return the todos
def load():
    todos = []
    todofiles = get_todo_files()
    for f in todofiles:
        t = []
        parse(f, t)
        todos.extend(t)
    return todos


################################################################################
# HELP SECTION
def showBriefHelp():
    print("""tt: Toodle-O TODO Manager
    $> tt + add todo :tag
    $> tt :tag
    $> tt -v :tag
    $> tt -x :tag search
    $> tt -t

Use -hh (or --man) to see detailed help
    $> tt -hh
""")


def showDetailedHelp():
    print("""tt: Toodle-O TODO Manager

Add a new todo (+)
    $> tt + add a new todo

Add a new todo with tags (:)
    $> tt + buy bread :joes :shopping

Find todo's matching a tag
    $> tt :shopping
    buy bread

Find todo's which don't have tags
    $> tt :
    add a new todo


Use :tag1+tag2 to associate two tags
    $> tt + buy wine :bws+shopping

Now searching will bring up both
    $> tt :shopping
    buy bread
    buy wine

You can restrict the search using (:tag:)
    $> tt :bws:
    buy wine

Use the special :later: tag to hide items
that will not be shown until you explicitly search
for it:
    $> tt :project :later:


Add the -v (verbose) to get more details
    $> tt :tag -v

And -t (tags) to get the list of tags
    $> tt -t

And -x (done) to mark matching items as complete
    $> tt -x :shopping bread
    x buy bread

If you want to manage multiple todo files,
create a "toodle-o.list" file each line of
which contains the path to each todo file.""")
################################################################################

main()

