#!/usr/bin/env python3
import sys
import re
import os

################################################################################
# MAIN SECTION

#   understand/
# main entry point into our program
def main():
    try:
        c, ar = processCmdLineArgs()
        if ar:
            c(ar)
        else:
            c()
    except Exception as e:
        print(str(e))


################################################################################
# ARGV SECTION

#   understand/
# handle the command-line arguments and return
# a tuple of (command, argument, error)
def processCmdLineArgs():
    if len(sys.argv) == 1:
        return (showBriefHelp, None)

    cmd = sys.argv[1]

    if not cmd.startswith("-"):
        return (search, ' '.join(sys.argv[1:]))
    cmd = re.sub("^-+", "", cmd)

    if cmd == "+":
        return ("add_todo", ' '.join(sys.argv[1:]))

    if cmd == "v":
        return (search_verbose, ' '.join(sys.argv[1:]))

    if cmd == "x":
        return ("mark_done", ' '.join(sys.argv[1:]))

    if cmd == "t":
        if len(sys.argv) > 2:
            raise Exception('"-t" cannot have any arguments')
        return ("tag_list", None)

    if cmd == "hh" or cmd == "man":
        return (showDetailedHelp, None)

    return (showBriefHelp, None)

################################################################################
# SEARCH SECTION
def search_verbose(s):
    search_(s, True)

def search(s):
    search_(s, False)

def search_(s, verbose):
    todos = load()
    for t in todos:
        print(t)

################################################################################
# ENGINE SECTION

#       way/
# read the files specified in "toodle-o.list" or default to "todo.txt"
def get_todo_files():
    conf = os.path.join(os.path.dirname(__file__), "toodle-o.list")
    if os.path.exists(conf):
        with open(conf) as f:
            return [line.strip() for line in f.readlines()]
    return ["todo.txt"]

#       way/
# read file and parse each line
def parse(f, todos):

    #       problem/
    # parse line by it's type
    #
    #   todos:
    #       *
    #       -
    #       +
    #       #
    #       - [ ]
    #       = Tag =
    #       1.
    #       2.
    #   otherwise notes
    #
    # and recognize it's indent
    #   * ...
    #     * ...
    #   # ...
    #   ## ...
    #   == Tag ==
    #
    # and recognize the "done"
    #   x+ ...
    #   x3. ...
    #   - [X]
    #
    # and the tags
    #   + ... :tag :tag
    #
    #
    #       way/
    # if line matches
    #       == tag name ==
    #       ## tag name ##
    # use that as a `:tag-name` and indent for a todo
    # otherwise
    # if line starts with `x` mark as "done" and
    # discard.
    # mark the number of leading spaces as "indent" and
    # discard.
    # if the line starts with =,#,*,+,- or
    # [number]. followed by a space it's a todo - clear
    # additional []/[ ]/[x]
    # otherwise
    # it is a note
    def parse_(l, fname):
        done = False
        note = l
        indent = 0
        ret = {
            #"orig": l,
            "fname": f,
        }

        todo = type_1("^\s*(=+)\s+(.*?)(=+)\s*$", l)
        if todo:
            ret.update(todo)
            return ret
        todo = type_1("^\s*(#+)\s+(.*?)(#*)\s*$", l)
        if todo:
            ret.update(todo)
            return ret

        if len(l) > 0 and (l[0] == 'x' or l[0] == 'X'):
            l = l[1:]
            done = True

        m = re.match("^\s+", l)
        if m:
            indent = len(m.group(0))

        l = l.strip()
        if len(l) > 0:
            m = re.match("^[=#*+-]\s", l)
            if not m:
                m = re.match("^[0-9]+[.]\s", l)
            if m:
                l = l[len(m.group(0)):]
                l = re.sub("\[[-.x ]?\]", "", l, re.I)
                (tags, txt) = tagify_1(l)
                if tags:
                    ret["tags"] = tags
                if txt:
                    ret["item"] = txt
                if done:
                    ret["done"] = done
                if indent > 0:
                    ret["indent"] = indent
                return ret


        ret["note"] = note
        return ret


    def tagify_1(l):
        tags = []
        rx = ":([^\s]+):?"
        m = re.match(rx, l)
        while m:
            tags.append(m.group(1))
            l = l.replace(m.group(0), '')
            m = re.match(rx, l)
        txt = l.strip()
        return (tags, txt)

    def type_1(rx, l):
        m = re.match(rx, l)
        if not m:
            return None
        m1 = m.group(1)
        m2 = m.group(3)
        if m2 and m1 != m2:
            return None
        txt = m.group(2).strip()
        if not txt:
            return None
        ret = {
            "tags": [ re.sub("\s+", "-", txt).lower() ]
        }
        indent = len(m1) - 1
        if indent > 0:
            ret["indent"] = indent
        return ret



    with open(f) as t:
        for line in t:
            l = parse_(line.rstrip(), f)
            todos.append(l)


################################################################################
# SEARCH SECTION

#       way/
# parse the todo files and return the todos
def load():
    todos = []
    todofiles = get_todo_files()
    for f in todofiles:
        parse(f, todos)
    return todos


################################################################################
# HELP SECTION
def showBriefHelp():
    print("""tt: Toodle-O TODO Manager
    $> tt + add todo :tag
    $> tt :tag
    $> tt -v :tag
    $> tt -x :tag search
    $> tt -t

Use -hh (or --man) to see detailed help
    $> tt -hh
""")


def showDetailedHelp():
    print("""tt: Toodle-O TODO Manager

Add a new todo (+)
    $> tt + add a new todo

Add a new todo with tags (:)
    $> tt + buy bread :joes :shopping

Find todo's matching a tag
    $> tt :shopping
    buy bread

Find todo's which don't have tags
    $> tt :
    add a new todo


Use :tag1+tag2 to associate two tags
    $> tt + buy wine :bws+shopping

Now searching will bring up both
    $> tt :shopping
    buy bread
    buy wine

You can restrict the search using (:tag:)
    $> tt :bws:
    buy wine

Use the special :later: tag to hide items
that will not be shown until you explicitly search
for it:
    $> tt :project :later:


Add the -v (verbose) to get more details
    $> tt :tag -v

And -t (tags) to get the list of tags
    $> tt -t

And -x (done) to mark matching items as complete
    $> tt -x :shopping bread
    x buy bread

If you want to manage multiple todo files,
create a "toodle-o.list" file each line of
which contains the path to each todo file.""")
################################################################################

main()

